grammar Udmf
{
  options
  {
    Axiom = "translation_unit";
    Separator = "SEPARATOR";
    Namespace = "SectorDirector.Core.FormatModels.Udmf.Parsing";
    AccessModifier = "Public";
  }
  terminals
  {
    WHITE_SPACE   -> U+0020 | U+0009 | U+000A | U+000B | U+000C | U+000D ;
    SEPARATOR     -> WHITE_SPACE+;

    IDENTIFIER    -> [A-Za-z_]+ [A-Za-z0-9_]*;

    // These two are too simplistic but they seem to work for real-world scenarios
    // NOTE: Keyword must come after Identifier, otherwise they get confused for each other
    KEYWORD       -> 'true' | 'false';
    QUOTED_STRING -> '"'[A-Za-z0-9_ .;:]*'"';

    INTEGER       -> [+-]?[0-9]+ 
                  |  '0x'[0-9A-Fa-f]+;

    FLOAT         -> [+-]?[0-9]+'.'[0-9]*([eE][+-]?[0-9]+)?;
  }
  rules
  {
    value -> INTEGER | FLOAT | QUOTED_STRING | KEYWORD;

    assignment_expr -> IDENTIFIER '=' value ';';

    block -> IDENTIFIER '{' assignment_expr* '}';

    global_expr -> block | assignment_expr;

    translation_unit -> global_expr+;
  }
}